---
title:  "Linux内核 11-02"
date:   2015-11-02 20:30:00
tags: [Linux, 操作系统]
categories: [Linux]
---

### 2015-11-2

當前進程

>編程手冊:任務切換

現場保護 保存段面

進程0創建進程一 tss ljmp 實際含義 硬件操作 彈出進程一的tss1給cpu 其中重要的是eip

**這個時候也需要保存現場，當前還是進程0，還需要恢復進程0的現場。執行跳轉的哪一個段面需要送到tss0**，期間執行了多次壓棧。

>這與一般程序的壓棧過程不同。這裏是結構體，一般程序是棧。棧的規則是後進先出，而結構體應該有選擇哪個數據彈出的功能。整個保存西現場，恢復現場的工作都由一行代碼ljmp完成，其他工作由硬件電路完成。

這一行執行完畢，將gdt中tss0彈出。此時ljmp是0特權級的代碼，操作的是內核資源。跳轉之後是3特權級代碼。
這一代碼並沒有寫出明確的特權級跳轉操作，然而實際上的確進行了跳轉。這就引出了**門**的概念，任務門，中斷門等等。

首先為什麼要設定特權級？

>*  保護內核代碼，防止低特權級代碼篡改繫統關鍵信息
*  創造特權壁壘，不論3特權級代碼如何設計，都不會進入繫統內核
*  同時保證正常程序能夠進行繫統調用，使用內核代碼

#### 門

禁止的是跳轉的任意性/主動性，允許的是繫統指定的地方，跳轉到指定的目的，一切都是有既定規則/計劃的/被動的。

中斷並不是一個任意的行為。是在繫統監督下，使用固定的繫統資源int80 idt system_call進行的繫統操作。

>也就是說，特權級壁壘實際上是為了保護使用跳轉機制對繫統資源使用的正確性，使idt真實有效地管理繫統資源。跳轉機制是為了維護特權級壁壘的堅固，保證idt不被隨意篡改。

然而這一行代碼是怎麼實現特權級切換的？

>tss存儲了一大堆寄存器信息，而特權級實際上是一種存儲的訪問控制機制，通過硬件的設置，來控制存儲的訪問權限。從tss一變，那麽寄存器中各種指針也相應地發生了變化，這樣段地址，指令地址都變了。而特權級是作用於段上的，段變了，特權級也就相應地變了。

硬件的設置，保證了一個跳轉，必須有當前段，即起跳段，和目標段。而這兩個段的地址CPU都已經知道了，並且允許這個跳轉/尋址執行，同時執行一個中斷。

>CPU對特權級的執行，體現在它對尋址過程的放行與否。它將通常的尋址禁止，而放行從特殊位置來的尋址請求。

**《Intel繫統編程手冊》**

這一行執行之後，進入繫統中斷int80 system_call，就跳轉到地方執行了。那麽往下的半個函數的程序，什麼時候執行？

>當前是0進程，中斷先保護0的現場，彈出1的地址，本來函數中下一行代碼地址在eip中，由於中斷保護現場，它被存到了進程0的tss中，因此當進程0的現場恢復的時候，恢復了tss0，就會執行下一行。

所以在下次schedule.switch_to時，就會恢復tss，於是接下來執行後半個函數。

### ljmp后緩衝區的創建

#### sys_setup函數與緩衝區

開始一大堆都是根文件繫統的初始化。

**緩衝區**

>操作繫統對硬盤的操作，都是經過緩衝區（內存）的中轉。目的∶快。關鍵∶**複用**。並不是每個讀寫操作，都使用硬盤。而是將重複的內容寫入內存，需要的時候提供內存中的這個副本。內存的讀寫速度可比硬盤快太多了。緩衝區就相當於一塊高速虛擬盤。它以塊為單位。

複用策略

主動邀請，被動等待

等待的代價是佔用內存。存的時間長，其他進程效率就低，短複用就少。需要平衡二者的矛盾。

讀使用上述策略是可行的。那麽寫呢？

考慮到寫的內容有可能多次更改，以及其他用戶併發地訪問，這樣就又涉及到非常多的讀操作。於是由讀操作的優勢，寫操作同樣也需要緩衝區。

而什麼時候將緩衝區內容dump到硬盤呢？這由操作繫統的策略決定。
